---
applyTo: "**/*.tf,**/*.hcl,**/terraform.tf,**/variables.tf,**/outputs.tf,**/locals.tf"
---
# Terraform Module Development Guidelines

{% if repository.has_infra %}
This document outlines comprehensive guidelines for Terraform module development in {{ repository.name }}, covering infrastructure as code best practices, module design patterns, and enterprise-grade development standards.
{% endif %}

## Documentation Standards

- Write clear and concise documentation for all changes in CHANGELOG.md using conventional format: FEATURES, ENHANCEMENTS, BUG FIXES
- Keep README.md current with examples, usage instructions, and requirements
- Include examples in the `examples/` directory for common use cases and testing
- Use inline comments for complex logic or non-obvious code
- Document all variables with clear descriptions and appropriate default values
- Structure examples as end-to-end tests and documentation sources
- Use terraform-docs for automated documentation generation
- Separate Terraform code into logical files for maintainability and reusability

## Naming Conventions

- Use snake_case for all Terraform components (variables, resources, outputs, locals)
- Use descriptive names that clearly indicate the purpose
- Prefix internal/private variables with underscore if needed
- Use consistent naming patterns across all modules and resources
- Implement standardized naming conventions using external modules or locals
- Expose suffix variables for customization while maintaining naming consistency
- Generate names for both standalone resources and resource collections

## Code Structure and Organization

- Organize files logically: variables.tf, main.tf, outputs.tf, versions.tf, locals.tf
- Group related resources in separate files when modules grow large
- Use locals.tf for computed values and complex expressions
- Include metadata files for module and example documentation
- Maintain clear separation between input variables, computed values, and outputs
- Keep resource definitions focused and single-purpose
- Use data sources appropriately for external dependencies
- Use configuration locals as intermediary between user inputs and resource definitions for more complex scenarios or when data transformation required.

## Variable Design

- Variable names are starting with a noun and ending with a verb, like feature_enabled.
- Always include type constraints for variables
- Provide meaningful default values where appropriate
- Use validation blocks to enforce business rules and constraints
- Validation errors should be clear and actionable. Try to use a single sentence if possible.
- Mark sensitive variables appropriately
- Use object types for complex configurations
- Prefer optional() for object attributes when flexibility is needed
- Prefered order of using collection types are map() > set() > list(). Use lists only when having a constant index is required and cannot be achieved through transformation of other collection types.

## Output Design

- Include all relevant output values in the outputs.tf file
- Use descriptive names for output variables
- Add description to each output variable with purpose and usage. This information also incorporated by tfdocs when generating USAGE.md
- When the output of a resource either contains sensitive values, or is a collection of resources (map, set, list), build up intermediary locals and separate sensitive outputs from non-sensitive ones.

## Resource Management

- Use for_each instead of count for creating multiple resources when possible
- Implement proper resource dependencies with depends_on when implicit dependencies aren't sufficient
- Use lifecycle blocks to prevent unwanted resource destruction
- Implement moved blocks for resource refactoring to maintain state continuity

## Error Handling and Validation

- Validate input variables at the variable level, not in resource blocks
- Provide clear and actionable error messages
- Use precondition and postcondition blocks for runtime validation
- Handle edge cases gracefully

## Security Best Practices

- Never hardcode sensitive values
- Use appropriate IAM principles (least privilege)
- Validate security-related inputs (email formats, resource names, etc.)
- Document security implications in variable descriptions

{% if 'terraform' in repository.languages %}
## Infrastructure as Code Best Practices

- Follow HashiCorp's Terraform best practices for {{ repository.name }}
- Use provider-specific data sources for dynamic values
- Implement proper resource tagging strategies
- Consider state file security and remote backend configuration
{% endif %}

## Module Versioning and Compatibility

- Follow semantic versioning (MAJOR.MINOR.PATCH)
- Document breaking changes clearly in CHANGELOG.md
- Use terraform.tf for modules for setting required_version constraints to the minimum version which supports all the funcionality the code requires. We only set providers and never for terraform itself, as we do not want to inadvertently restrict the use of newer Terraform features or older versions at all. We just want to ensure compatibility with the features we are using.
- Use the providers.tf in examples for setting used providers in the examples along with pinned provider versions.
- Provide migration guides for breaking changes
- Always update and sync versions between CHANGELOG.md, anchor.module, and locals.tf update local.tags.%MODULE_NAME% = "vMajor.Minor.Path" (for Azure and AWS resources) or the local.labels (for GCP).

## Testing and Quality Assurance

- Always run `terraform fmt` before committing
- Use `terraform init` and `terraform validate` to check syntax. Fall back to the -backend=false flag when backend is not available.
- Test modules with realistic examples
- Consider edge cases and failure scenarios
- Document known limitations

## Performance Considerations

- Minimize API calls by batching operations where possible
- Use appropriate data source filters
- Consider the impact of for_each loops on plan/apply times
- Cache expensive computations in locals

## Provider Usage

- Specify minimum required provider versions
- Use provider features appropriately (aliases, configurations)
- Handle provider-specific limitations gracefully
- Document provider-specific requirements

{% if detected_instructions %}
## Related Documentation

For additional development guidance, see:
{% for instruction in detected_instructions %}
{% if instruction.filename != 'terraform.instructions.md' %}
- **{{ instruction.display_name }}**: [{{ instruction.filename }}]({{ instruction.filename }}) - {{ instruction.purpose }}
{% endif %}
{% endfor %}
{% endif %}